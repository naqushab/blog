{"version":3,"sources":["webpack:///path---greedy-vs-dynamic-programming-92b3de293d244bbb937e.js","webpack:///./.cache/json/greedy-vs-dynamic-programming.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/greedy-vs-dynamic-programming.json","module","exports","data","site","siteMetadata","author","homeCity","markdownRemark","html","excerpt","fields","tagSlugs","frontmatter","title","tags","date","pathContext","slug"],"mappings":"AAAAA,cAAc,KAERC,uFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,MACAC,cACAC,OAAA,mBACAC,SAAA,UAGAC,gBACAC,KAAA,g6XACAC,QAAA,kJACAC,QACAC,UACA,yBACA,+BAGAC,aACAC,MAAA,oDACAC,MACA,kBACA,uBAEAC,KAAA,qBAIAC,aACAC,KAAA","file":"path---greedy-vs-dynamic-programming-92b3de293d244bbb937e.js","sourcesContent":["webpackJsonp([32],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/greedy-vs-dynamic-programming.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"site\": {\n\t\t\t\t\"siteMetadata\": {\n\t\t\t\t\t\"author\": \"Naqushab Neyazee\",\n\t\t\t\t\t\"homeCity\": \"Noida\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>Dynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still surprise you. But as everything else in life, practice makes you better ;-)</p>\\n<p>Other answers in this thread mention some nice introductory texts that will help you understand what DP is and how it works. In the following few paragraphs I will try to show you how to come up with solutions for DP problems.</p>\\n<p>Note: the process of creating a DP solution, I describe below, is directly applicable for all the Div1-250 problems and many of Div1-500 problems on TopCoder which can be solved with DP. Harder problems usually requires some alternation in the process which you will be able to do, after some practice.\\nNote 2: the source code samples below are written in C++. If you don’t know the language or are unsure of something, please ask me in comments.</p>\\n<h2>Iteration vs. recursion</h2>\\n<p>After you read some introductory texts on dynamic programming (which I highly recommend), pretty much all the source code examples in them use bottom-up technique with iteration (i.e. using for-cycles). For example calculating the length of the longest common subsequence of two strings <em>A</em> and <em>B</em> of length <em>N</em>, would look like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int dp[N+1][N+1];\\nfor (int i = 0; i <= N; ++i)\\n  dp[0][i] = dp[i][0] = 0;\\nfor (int i = 1; i <= N; ++i)\\n  for (int j = 1; j <= N; ++j) {\\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n    if (A[i-1] == B[j-1])\\n      dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);\\n  }\\n\\nint answer = dp[N][N];</code></pre>\\n      </div>\\n<p>There are couple of reasons why it is coded in this way:</p>\\n<ol>\\n<li>iteration is much faster than recursion</li>\\n<li>one can easily see time and space complexity of the algorithm</li>\\n<li>source code is short and clean</li>\\n</ol>\\n<p>Looking at such source code, one can understand how and why it works, but it is much harder to understand how to come up with it.\\nThe biggest breakthrough in my learning of dynamic programming was, when I started to think about the problems in the top-down fashion, instead of bottom-up.\\nOn the first look it doesn’t look as such a revolutionary insight, but these two approaches directly translates in two different source codes. One uses iteration (bottom-up fashion) and the other one uses recursion (top-down fashion). The latter one is also called the memoization technique. The two solutions are more or less equivalent and you can always transform one into the other.\\nIn the following paragraphs I will show you how to come up with a memoization solution for a problem.</p>\\n<h2>Motivation problem</h2>\\n<p>Imagine you have a collection of <em>N</em> wines placed next to each other on a shelf. For simplicity, let’s number the wines from left to right as they are standing on the shelf with integers from 1 to <em>N</em>, respectively. The price of the <em>i</em>-th wine is <em>pi</em> (prices of different wines can be different).\\nBecause the wines get better every year, supposing today is the year 1, on year <em>y</em> the price of the <em>i</em>-th wine will be *y<em>**pi</em>, i.e. <em>y</em>-times the value that current year.</p>\\n<p>You want to sell all the wines you have, but you want to sell exactly one wine per year, starting on this year. One more constraint - on each year you are allowed to sell only either the leftmost or the rightmost wine on the shelf and you are not allowed to reorder the wines on the shelf (i.e. they must stay in the same order as they are in the beginning).</p>\\n<p>You want to find out, what is the maximum profit you can get, if you sell the wines in optimal order.\\nSo for example, if the prices of the wines are (in the order as they are placed on the shelf, from left to right): <em>p1=</em>1, <em>p2=</em>4, <em>p3=</em>2, <em>p4=</em>3\\nThe optimal solution would be to sell the wines in the order <em>p1, p4, p3, p2</em> for a total profit 1<em>1 + 3</em>2 + 2<em>3 + 4</em>4 = 29</p>\\n<h2>Wrong solution</h2>\\n<p>After playing with the problem for a while, you’ll probably get the feeling, that in the optimal solution you want to sell the expensive wines as late as possible. You can probably come up with the following greedy strategy:</p>\\n<blockquote>\\n<p>Every year, sell the cheaper of the two (leftmost and rightmost) available wines.</p>\\n</blockquote>\\n<p>Although the strategy doesn’t mention what to do when the two wines cost the same, this strategy kinda feels right. But unfortunately, it isn’t, as the following example demonstrates. If the prices of the wines are: <em>p1</em>=2, <em>p2</em>=3, <em>p3</em>=5, <em>p4</em>=1, <em>p5</em>=4\\nThe greedy strategy would sell them in the order <em>p1, p2, p5, p4, p3</em> for a total profit 2<em>1 + 3</em>2 + 4<em>3 + 1</em>4 + 5<em>5 = 49\\nBut we can do better if we sell the wines in the order </em>p1, p5, p4, p2, p3 <em>for a total profit 2</em>1 + 4<em>2 + 1</em>3 + 3<em>4 + 5</em>5 = 50\\nThis counter-example should convince you, that the problem is not so easy as it can look on a first sight and I will tell you, that it can be solved using DP.</p>\\n<h2>Write a backtrack</h2>\\n<p>When coming up with the memoization solution for a problem, I always start with a backtrack solution that finds the correct answer. Backtrack solution enumerates all the valid answers for the problem and chooses the best one. For most of the problems it is easy to come up with such solution.\\nHere are some restrictions I put on a backtrack solution:</p>\\n<ul>\\n<li>it should be a function, calculating the answer using recursion</li>\\n<li>it should return the answer with <em>return</em> statement, i.e. not store it somewhere</li>\\n<li>all the non-local variables that the function uses should be used as read-only, i.e. the function can modify only local variables and its arguments.</li>\\n</ul>\\n<p>So for the problem with wines, the backtrack solution will look like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int p[N]; // read-only array of wine prices\\n\\n// year represents the current year (starts with 1)\\n// [be, en] represents the interval of the unsold wines on the shelf\\nint profit(int year, int be, int en) {\\n  // there are no more wines on the shelf\\n  if (be > en)\\n    return 0;\\n\\n  // try to sell the leftmost or the rightmost wine, recursively calculate the \\n  // answer and return the better one\\n  return max(\\n    profit(year+1, be+1, en) + year * p[be],\\n    profit(year+1, be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>We can get the answer by calling:</p>\\n<p><code>int answer = profit(1, 0, N-1); // N is the total number of wines</code></p>\\n<p>This solution simply tries all the possible valid orders of selling the wines. If there are <em>N</em> wines in the beginning, it will try 2^<em>N</em> possibilities (each year we have 2 choices). So even though now we get the correct answer, the time complexity of the algorithm grows exponentially.</p>\\n<p>The correctly written backtrack function should always represent an answer to a well-stated question. In our case <em>profit</em> function represents an answer to a question: ”<em>What is the best profit we can get from selling the wines with prices stored in the array <strong>p</strong>, when the current year is <strong>year</strong> and the interval of unsold wines spans through [<strong>be,**</strong> *<strong>*en</strong>], inclusive?</em>”</p>\\n<p>You should always try to create such a question for your backtrack function to see if you got it right and understand exactly what it does.</p>\\n<h2>Minimize the state space of function arguments</h2>\\n<p>In this step I want you to think about, which of the arguments you pass to the function are redundant. Either we can construct them from the other arguments or we don’t need them at all. If there are any such arguments, don’t pass them to the function. Just calculate them inside the function.</p>\\n<p>In the above function <em>profit</em>, the argument <em>year</em> is redundant. It is equivalent to the number of wines we have already sold plus one, which is equivalent to the total number of wines from the beginning minus the number of wines we have not sold plus one. If we create a read-only global variable <em>N</em>, representing the total number of wines in the beginning, we can rewrite our function as follows:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int N; // read-only number of wines in the beginning\\nint p[N]; // read-only array of wine prices\\n\\nint profit(int be, int en) {\\n  if (be > en)\\n    return 0;\\n\\n  // (en-be+1) is the number of unsold wines\\n  int year = N - (en-be+1) + 1; // as in the description above\\n  return max(\\n    profit(be+1, en) + year * p[be],\\n    profit(be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>I also want you to think about the range of possible values the function arguments can get from a valid input. In our case, each of the arguments <em>be</em> and <em>en</em> can contain values from 0 to <em>N</em>-1. In valid inputs we also expect <em>be</em> &#x3C;= <em>en</em>+1. Using big-O notation we can say, there are O(<em>N</em>^2) different arguments our function can be called with.</p>\\n<h2>Now cache it!</h2>\\n<p>We are now 99% done. To transform the backtrack function with time complexity O(2^<em>N</em>) into the memoization solution with time complexity O(<em>N</em>^2) we will use a little trick which doesn’t require almost any thinking.\\nAs noted above, there are only O(<em>N</em>^2) different arguments our function can be called with. In other words, there are only O(<em>N</em>^2) different things we can actually compute. So where does O(2^N) time complexity comes from and what does it compute?!\\nThe answer is - the exponential time complexity comes from the repeated recursion and because of that, it computes the same values again and again. If you run the above code for an arbitrary array of <em>N</em>=20 wines and calculate how many times was the function called for arguments <em>be</em>=10 and <em>en</em>=10 you will get a number 92378. That’s a huge waste of time to compute the same answer that many times. What we can do to improve this is to cache the values once we have computed them and every time the function asks for an already cached value, we don’t need to run the whole recursion again. See the code below:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int N; // read-only number of wines in the beginning\\nint p[N]; // read-only array of wine prices\\nint cache[N][N]; // all values initialized to -1 (or anything you choose)\\n\\nint profit(int be, int en) {\\n  if (be > en)\\n    return 0;\\n\\n  // these two lines save the day\\n  if (cache[be][en] != -1)\\n    return cache[be][en];\\n\\n  int year = N - (en-be+1) + 1;\\n  // when calculating the new answer, don't forget to cache it\\n  return cache[be][en] = max(\\n    profit(be+1, en) + year * p[be],\\n    profit(be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>And that’s it! With that little trick it runs O(<em>N</em>^2) time, because there are O(<em>N^2)</em> different arguments our function can be called with and for each of them, the function runs only once with O(1) time complexity.\\nNote: when the values are cached, you can treat every recursive call inside the function as it would run in O(1) time complexity.</p>\\n<h2>Summary</h2>\\n<p>To sum it up, if you identify that a problem can be solved using DP, try to create a backtrack function that calculates the correct answer. Try to avoid the redundant arguments, minimize the range of possible values of function arguments and also try to optimize the time complexity of one function call (remember, you can treat recursive calls as they would run in O(1) time). Finally cache the values and don’t calculate the same things twice.\\nThe final time complexity of the solution is:\\n<strong>range_of_possible_values_the_function_can_be_called_with</strong>\\nx <strong>time_complexity_of_one_function_call.</strong></p>\",\n\t\t\t\t\"excerpt\": \"Dynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still...\",\n\t\t\t\t\"fields\": {\n\t\t\t\t\t\"tagSlugs\": [\n\t\t\t\t\t\t\"/tags/greedy-solution/\",\n\t\t\t\t\t\t\"/tags/dynamic-programming/\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Difference between Greedy and Dynamic Programming\",\n\t\t\t\t\t\"tags\": [\n\t\t\t\t\t\t\"Greedy Solution\",\n\t\t\t\t\t\t\"Dynamic Programming\"\n\t\t\t\t\t],\n\t\t\t\t\t\"date\": \"August 25, 2017\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/greedy-vs-dynamic-programming/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---greedy-vs-dynamic-programming-92b3de293d244bbb937e.js","module.exports = {\n\t\"data\": {\n\t\t\"site\": {\n\t\t\t\"siteMetadata\": {\n\t\t\t\t\"author\": \"Naqushab Neyazee\",\n\t\t\t\t\"homeCity\": \"Noida\"\n\t\t\t}\n\t\t},\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>Dynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still surprise you. But as everything else in life, practice makes you better ;-)</p>\\n<p>Other answers in this thread mention some nice introductory texts that will help you understand what DP is and how it works. In the following few paragraphs I will try to show you how to come up with solutions for DP problems.</p>\\n<p>Note: the process of creating a DP solution, I describe below, is directly applicable for all the Div1-250 problems and many of Div1-500 problems on TopCoder which can be solved with DP. Harder problems usually requires some alternation in the process which you will be able to do, after some practice.\\nNote 2: the source code samples below are written in C++. If you don’t know the language or are unsure of something, please ask me in comments.</p>\\n<h2>Iteration vs. recursion</h2>\\n<p>After you read some introductory texts on dynamic programming (which I highly recommend), pretty much all the source code examples in them use bottom-up technique with iteration (i.e. using for-cycles). For example calculating the length of the longest common subsequence of two strings <em>A</em> and <em>B</em> of length <em>N</em>, would look like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int dp[N+1][N+1];\\nfor (int i = 0; i <= N; ++i)\\n  dp[0][i] = dp[i][0] = 0;\\nfor (int i = 1; i <= N; ++i)\\n  for (int j = 1; j <= N; ++j) {\\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n    if (A[i-1] == B[j-1])\\n      dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);\\n  }\\n\\nint answer = dp[N][N];</code></pre>\\n      </div>\\n<p>There are couple of reasons why it is coded in this way:</p>\\n<ol>\\n<li>iteration is much faster than recursion</li>\\n<li>one can easily see time and space complexity of the algorithm</li>\\n<li>source code is short and clean</li>\\n</ol>\\n<p>Looking at such source code, one can understand how and why it works, but it is much harder to understand how to come up with it.\\nThe biggest breakthrough in my learning of dynamic programming was, when I started to think about the problems in the top-down fashion, instead of bottom-up.\\nOn the first look it doesn’t look as such a revolutionary insight, but these two approaches directly translates in two different source codes. One uses iteration (bottom-up fashion) and the other one uses recursion (top-down fashion). The latter one is also called the memoization technique. The two solutions are more or less equivalent and you can always transform one into the other.\\nIn the following paragraphs I will show you how to come up with a memoization solution for a problem.</p>\\n<h2>Motivation problem</h2>\\n<p>Imagine you have a collection of <em>N</em> wines placed next to each other on a shelf. For simplicity, let’s number the wines from left to right as they are standing on the shelf with integers from 1 to <em>N</em>, respectively. The price of the <em>i</em>-th wine is <em>pi</em> (prices of different wines can be different).\\nBecause the wines get better every year, supposing today is the year 1, on year <em>y</em> the price of the <em>i</em>-th wine will be *y<em>**pi</em>, i.e. <em>y</em>-times the value that current year.</p>\\n<p>You want to sell all the wines you have, but you want to sell exactly one wine per year, starting on this year. One more constraint - on each year you are allowed to sell only either the leftmost or the rightmost wine on the shelf and you are not allowed to reorder the wines on the shelf (i.e. they must stay in the same order as they are in the beginning).</p>\\n<p>You want to find out, what is the maximum profit you can get, if you sell the wines in optimal order.\\nSo for example, if the prices of the wines are (in the order as they are placed on the shelf, from left to right): <em>p1=</em>1, <em>p2=</em>4, <em>p3=</em>2, <em>p4=</em>3\\nThe optimal solution would be to sell the wines in the order <em>p1, p4, p3, p2</em> for a total profit 1<em>1 + 3</em>2 + 2<em>3 + 4</em>4 = 29</p>\\n<h2>Wrong solution</h2>\\n<p>After playing with the problem for a while, you’ll probably get the feeling, that in the optimal solution you want to sell the expensive wines as late as possible. You can probably come up with the following greedy strategy:</p>\\n<blockquote>\\n<p>Every year, sell the cheaper of the two (leftmost and rightmost) available wines.</p>\\n</blockquote>\\n<p>Although the strategy doesn’t mention what to do when the two wines cost the same, this strategy kinda feels right. But unfortunately, it isn’t, as the following example demonstrates. If the prices of the wines are: <em>p1</em>=2, <em>p2</em>=3, <em>p3</em>=5, <em>p4</em>=1, <em>p5</em>=4\\nThe greedy strategy would sell them in the order <em>p1, p2, p5, p4, p3</em> for a total profit 2<em>1 + 3</em>2 + 4<em>3 + 1</em>4 + 5<em>5 = 49\\nBut we can do better if we sell the wines in the order </em>p1, p5, p4, p2, p3 <em>for a total profit 2</em>1 + 4<em>2 + 1</em>3 + 3<em>4 + 5</em>5 = 50\\nThis counter-example should convince you, that the problem is not so easy as it can look on a first sight and I will tell you, that it can be solved using DP.</p>\\n<h2>Write a backtrack</h2>\\n<p>When coming up with the memoization solution for a problem, I always start with a backtrack solution that finds the correct answer. Backtrack solution enumerates all the valid answers for the problem and chooses the best one. For most of the problems it is easy to come up with such solution.\\nHere are some restrictions I put on a backtrack solution:</p>\\n<ul>\\n<li>it should be a function, calculating the answer using recursion</li>\\n<li>it should return the answer with <em>return</em> statement, i.e. not store it somewhere</li>\\n<li>all the non-local variables that the function uses should be used as read-only, i.e. the function can modify only local variables and its arguments.</li>\\n</ul>\\n<p>So for the problem with wines, the backtrack solution will look like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int p[N]; // read-only array of wine prices\\n\\n// year represents the current year (starts with 1)\\n// [be, en] represents the interval of the unsold wines on the shelf\\nint profit(int year, int be, int en) {\\n  // there are no more wines on the shelf\\n  if (be > en)\\n    return 0;\\n\\n  // try to sell the leftmost or the rightmost wine, recursively calculate the \\n  // answer and return the better one\\n  return max(\\n    profit(year+1, be+1, en) + year * p[be],\\n    profit(year+1, be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>We can get the answer by calling:</p>\\n<p><code>int answer = profit(1, 0, N-1); // N is the total number of wines</code></p>\\n<p>This solution simply tries all the possible valid orders of selling the wines. If there are <em>N</em> wines in the beginning, it will try 2^<em>N</em> possibilities (each year we have 2 choices). So even though now we get the correct answer, the time complexity of the algorithm grows exponentially.</p>\\n<p>The correctly written backtrack function should always represent an answer to a well-stated question. In our case <em>profit</em> function represents an answer to a question: ”<em>What is the best profit we can get from selling the wines with prices stored in the array <strong>p</strong>, when the current year is <strong>year</strong> and the interval of unsold wines spans through [<strong>be,**</strong> *<strong>*en</strong>], inclusive?</em>”</p>\\n<p>You should always try to create such a question for your backtrack function to see if you got it right and understand exactly what it does.</p>\\n<h2>Minimize the state space of function arguments</h2>\\n<p>In this step I want you to think about, which of the arguments you pass to the function are redundant. Either we can construct them from the other arguments or we don’t need them at all. If there are any such arguments, don’t pass them to the function. Just calculate them inside the function.</p>\\n<p>In the above function <em>profit</em>, the argument <em>year</em> is redundant. It is equivalent to the number of wines we have already sold plus one, which is equivalent to the total number of wines from the beginning minus the number of wines we have not sold plus one. If we create a read-only global variable <em>N</em>, representing the total number of wines in the beginning, we can rewrite our function as follows:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int N; // read-only number of wines in the beginning\\nint p[N]; // read-only array of wine prices\\n\\nint profit(int be, int en) {\\n  if (be > en)\\n    return 0;\\n\\n  // (en-be+1) is the number of unsold wines\\n  int year = N - (en-be+1) + 1; // as in the description above\\n  return max(\\n    profit(be+1, en) + year * p[be],\\n    profit(be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>I also want you to think about the range of possible values the function arguments can get from a valid input. In our case, each of the arguments <em>be</em> and <em>en</em> can contain values from 0 to <em>N</em>-1. In valid inputs we also expect <em>be</em> &#x3C;= <em>en</em>+1. Using big-O notation we can say, there are O(<em>N</em>^2) different arguments our function can be called with.</p>\\n<h2>Now cache it!</h2>\\n<p>We are now 99% done. To transform the backtrack function with time complexity O(2^<em>N</em>) into the memoization solution with time complexity O(<em>N</em>^2) we will use a little trick which doesn’t require almost any thinking.\\nAs noted above, there are only O(<em>N</em>^2) different arguments our function can be called with. In other words, there are only O(<em>N</em>^2) different things we can actually compute. So where does O(2^N) time complexity comes from and what does it compute?!\\nThe answer is - the exponential time complexity comes from the repeated recursion and because of that, it computes the same values again and again. If you run the above code for an arbitrary array of <em>N</em>=20 wines and calculate how many times was the function called for arguments <em>be</em>=10 and <em>en</em>=10 you will get a number 92378. That’s a huge waste of time to compute the same answer that many times. What we can do to improve this is to cache the values once we have computed them and every time the function asks for an already cached value, we don’t need to run the whole recursion again. See the code below:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>int N; // read-only number of wines in the beginning\\nint p[N]; // read-only array of wine prices\\nint cache[N][N]; // all values initialized to -1 (or anything you choose)\\n\\nint profit(int be, int en) {\\n  if (be > en)\\n    return 0;\\n\\n  // these two lines save the day\\n  if (cache[be][en] != -1)\\n    return cache[be][en];\\n\\n  int year = N - (en-be+1) + 1;\\n  // when calculating the new answer, don't forget to cache it\\n  return cache[be][en] = max(\\n    profit(be+1, en) + year * p[be],\\n    profit(be, en-1) + year * p[en]);\\n}</code></pre>\\n      </div>\\n<p>And that’s it! With that little trick it runs O(<em>N</em>^2) time, because there are O(<em>N^2)</em> different arguments our function can be called with and for each of them, the function runs only once with O(1) time complexity.\\nNote: when the values are cached, you can treat every recursive call inside the function as it would run in O(1) time complexity.</p>\\n<h2>Summary</h2>\\n<p>To sum it up, if you identify that a problem can be solved using DP, try to create a backtrack function that calculates the correct answer. Try to avoid the redundant arguments, minimize the range of possible values of function arguments and also try to optimize the time complexity of one function call (remember, you can treat recursive calls as they would run in O(1) time). Finally cache the values and don’t calculate the same things twice.\\nThe final time complexity of the solution is:\\n<strong>range_of_possible_values_the_function_can_be_called_with</strong>\\nx <strong>time_complexity_of_one_function_call.</strong></p>\",\n\t\t\t\"excerpt\": \"Dynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still...\",\n\t\t\t\"fields\": {\n\t\t\t\t\"tagSlugs\": [\n\t\t\t\t\t\"/tags/greedy-solution/\",\n\t\t\t\t\t\"/tags/dynamic-programming/\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Difference between Greedy and Dynamic Programming\",\n\t\t\t\t\"tags\": [\n\t\t\t\t\t\"Greedy Solution\",\n\t\t\t\t\t\"Dynamic Programming\"\n\t\t\t\t],\n\t\t\t\t\"date\": \"August 25, 2017\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/greedy-vs-dynamic-programming/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/greedy-vs-dynamic-programming.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/greedy-vs-dynamic-programming.json\n// module chunks = 32"],"sourceRoot":""}