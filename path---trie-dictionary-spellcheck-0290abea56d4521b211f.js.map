{"version":3,"sources":["webpack:///path---trie-dictionary-spellcheck-0290abea56d4521b211f.js","webpack:///./.cache/json/trie-dictionary-spellcheck.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/trie-dictionary-spellcheck.json","module","exports","data","site","siteMetadata","author","homeCity","markdownRemark","html","excerpt","fields","tagSlugs","frontmatter","title","tags","date","pathContext","slug"],"mappings":"AAAAA,cAAc,IAERC,oFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,MACAC,cACAC,OAAA,mBACAC,SAAA,UAGAC,gBACAC,KAAA,mqZACAC,QAAA,+IACAC,QACAC,UACA,yBACA,gBAGAC,aACAC,MAAA,2DACAC,MACA,kBACA,QAEAC,KAAA,qBAIAC,aACAC,KAAA","file":"path---trie-dictionary-spellcheck-0290abea56d4521b211f.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/trie-dictionary-spellcheck.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"site\": {\n\t\t\t\t\"siteMetadata\": {\n\t\t\t\t\t\"author\": \"Naqushab Neyazee\",\n\t\t\t\t\t\"homeCity\": \"Noida\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"markdownRemark\": {\n\t\t\t\t\"html\": \"<p>This article walks through writing a spell-checking algorithm, making use of a neat data structure called a <a href=\\\"https://en.wikipedia.org/wiki/Trie\\\">trie</a>, which is particularly suited to the problem.</p>\\n<p>We will look at:</p>\\n<ul>\\n<li>The spell-checking problem and naive solutions</li>\\n<li>What a trie is and how it can offer us a better solution</li>\\n<li>The trie-based solution</li>\\n<li>Analysis of our solution</li>\\n<li>How our solution can be improved</li>\\n<li>Other problems that can be solved with tries</li>\\n</ul>\\n<h2>Problem</h2>\\n<p>We wish to write a spell-checking algorithm which should return a boolean indicating whether the word might be valid or not. It should return false only if there is no possibility of the word being correct. Words which are incorrect but may be made correct with the addition of further letters should return true.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>zebr -> true\\nzebra -> true\\nzebrak -> false</code></pre>\\n      </div>\\n<p>Let’s consider some solutions using conventional data structures.</p>\\n<p><strong>List.</strong> Sort words and store them in a <code>list</code>. We can then use a modified binary search ^<em>1</em> to search for words in <code>O(m log n)</code> time ^<em>2</em>, where m is the length of the search term and n is the number of words in the dictionary. This isn’t a bad solution, but we can do better.</p>\\n<p><strong>Dict/set.</strong> Store words in a <code>dict</code> or a <code>set</code>. Dicts and sets use hashing algorithms to provide constant time (<code>O(1)</code>) lookups. This makes them seem suitable for an algorithm which is mostly about looking up whether a word is in a list. However, our spell-checker should not return false for the word the user is currently typing, even if it is not yet a valid word. In hashing the words in the list, we lose information about the word itself, and cannot map a word which can be made correct to the correct word. This makes dicts and sets unsuitable for this purpose.</p>\\n<h2>Tries</h2>\\n<p>A trie is a data structure which can store strings in a way which makes them easy to search. The following diagram shows a trie with the strings app, apple and cat stored in it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>0 -> a -> p -> p. -> l -> e.\\n `-> c -> a -> t.</code></pre>\\n      </div>\\n<p>In this diagram, <code>0</code> represents the node at the top of the trie, which has no value associated. Nodes marked are marked with a dot <code>.</code> to signify that they contain a letter which is at the end of a word.</p>\\n<p>The trie is made up of a series of interconnected nodes. Each node stores a single character, and interconnecting lines show the relationship between characters. By following the lines, we can see our three words</p>\\n<p>We can see that a trie explicitly encodes the characters of a word in its nodes, making it suitable for our spell-checking algorithm, where we need to be able to match substrings of words in the dictionary.</p>\\n<p>Our trie will need to support two operations:</p>\\n<ul>\\n<li><strong><code>insert</code></strong>, which adds a new word</li>\\n<li><strong><code>search</code></strong>, which searches for a match or potential match</li>\\n</ul>\\n<h2>Implementation</h2>\\n<p>First, let’s implement our trie. Tries consist of a series of nodes. Each node must store a value, a record of the child nodes, and whether the node points to the end of a complete word.</p>\\n<p>The child nodes can be stored in different ways, depending on the properties desired in the trie. Here, we store them in a dict, which offers fast <code>O(1)</code> lookup times, but require larger memory usage. A list could alternatively be used to reduce memory usage, at the cost of slower lookup time.</p>\\n<p>Using a <code>dict</code>, the algorithmic complexity of spell-checking a word should be <code>O(m)</code>, where <code>m</code> is the length of the string being checked ^<em>3</em>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Node(object):\\n   def __init__(self, value=None):\\n        self.value = value\\n        self.children = {}\\n        self.is_complete = False</code></pre>\\n      </div>\\n<p>The trie itself just contains a reference to the top of the string of nodes:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    def __init__(self):\\n        self.node = Node()</code></pre>\\n      </div>\\n<p>We can now implement the <code>insert</code> method:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def insert(self, key):\\n        node = self.node\\n        for letter in key:\\n            if letter in node.children:\\n                node = node.children[letter]\\n            else:\\n                new_node = Node(letter)\\n                node.children[letter] = new_node\\n                node = new_node\\n        node.is_complete = True</code></pre>\\n      </div>\\n<p>Insert takes a key to insert, iterates over it, and adds each letter to the trie, creating new nodes if necessary.</p>\\n<p><code>search</code> method:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def search(self, key):\\n        node = self.node\\n        for letter in key:\\n            if letter not in node.children:\\n                return False\\n            else:\\n                node = node.children[letter]\\n        return True</code></pre>\\n      </div>\\n<p>Search iterates over the letters in the key, checking that each node contains a child whose value matches the letter.</p>\\n<h2>Analysis</h2>\\n<h3>Comparison to binary search</h3>\\n<p>We can compare how our trie-based algorithm compares to binary search which by running a benchmark test. The test searches for 1000 randomly selected words from the dictionary 100 times each.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ python benchmark.py\\nBinary search 1000 items 100 times: 2.32307600975\\nTrie search 1000 items 100 times: 0.461572885513</code></pre>\\n      </div>\\n<h3>Complexity</h3>\\n<p>We can empirically measure the algorithm’s time complexity by measuring the time taken to search for words of variable length known to be in the trie.</p>\\n<p>\\n          <a\\n            class=\\\"gatsby-resp-image-link\\\"\\n            href=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-511e6.png\\\"\\n            style=\\\"display: block\\\"\\n            target=\\\"_blank\\\"\\n            rel=\\\"noopener\\\"\\n          >\\n            <span\\n              class=\\\"gatsby-resp-image-wrapper\\\"\\n              style=\\\"position: relative; z-index: -1; display: block; \\\"\\n            >\\n              <span\\n                class=\\\"gatsby-resp-image-background-image\\\"\\n                style=\\\"padding-bottom: 103.85674931129476%;position: relative; width: 100%; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsSAAALEgHS3X78AAABQElEQVQ4y52T2Y6DMAxF+f9/rFRUWs2UnSSQxU7mlkggllI6eYhubA6xHTsJIWitsyy73W6XywX74/FI0/R+v2fjul6vOEJYa/1yJYCVUswcz1sxaXwZ9xdiiCd4sm7FrrFURjv+D0ze/wgD9R0MhXiL3jjiEOGqqk7l7D2oUllLHC0vWAhx5ubecTuAnCv3Rdi5NHaM9jvYsa8GOzgOS2+CDjkOm32olFWWtt4EZF3XuwWDG3G2gxPaRWD1WYKma9t2t8ioDUhpXFiWfYbf5awdCUPK8m4uRwXDnU1ve8vvCjHDq4Ihz2YASQe9PcNN00w9hMare7wK+nfdYR9yxntiXAz5j1O1zhlk8SLpzEguYET5K3GlD+fmeQEr46LtYKr2cyYiTCX+IKUsyxI7dJ7nclxd1xVFEb3P5zMao/gDcjTXnEy6KcoAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n              >\\n                <img\\n                  class=\\\"gatsby-resp-image-image\\\"\\n                  style=\\\"width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n                  alt=\\\"Trie Search Complexity\\\"\\n                  title=\\\"\\\"\\n                  src=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-a408b.png\\\"\\n                  srcset=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-4eabf.png 148w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-5a375.png 295w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-a408b.png 590w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-9a0cc.png 885w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-aa987.png 1180w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-511e6.png 1452w\\\"\\n                  sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n                />\\n              </span>\\n            </span>\\n          </a>\\n          </p>\\n<p>Graph showing trie’s search has linear time complexity.</p>\\n<p><code>Trie.search</code> has linear time complexity, as expected.</p>\\n<h2>Improvements</h2>\\n<h3>Speed up searching successive characters in a word</h3>\\n<p>When spell-checking, a word as it is typed, we make multiple calls to the <code>search()</code> function, each time passing the previously searched value with a new character appended. For example, when typing the word ‘word’, the following searches are made:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>w\\nwo\\nwor\\nword</code></pre>\\n      </div>\\n<p>When searching for ‘wor’, you repeat the work done when searching for ‘wo’ and ‘w’. We can modify our algorithm to take this into account:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def search(self, key, prev_node=None):\\n        node = prev_node if prev_node is not None else self.node\\n        for letter in key:\\n            if letter not in node.children:\\n                return False, node\\n            else:\\n                node = node.children[letter]\\n        return True, node</code></pre>\\n      </div>\\n<p>In this code, the last searched node is returned to the caller. The caller can then supply this node when calling search with the next character in the word to continue searching when we left off.</p>\\n<h3>Startup time</h3>\\n<p>One disadvantage of this algorithm is that initialising the trie takes some time. By profiling the insertion of the dictionary into the trie, we can see that a lot of this time is spent initialising <code>Node</code> objects:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ python profile_trie_insert.py\\n     1028667 function calls in 5.354 seconds\\n\\nOrdered by: standard name\\n\\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\\n     1    0.176    0.176    5.354    5.354 <string>:1(<module>)\\n     1    0.101    0.101    5.178    5.178 profile_trie_insert.py:6(initialise_trie)\\n792777    3.273    0.000    3.273    0.000 trie_dict.py:12(__init__)\\n     1    0.000    0.000    0.000    0.000 trie_dict.py:20(__init__)\\n235886    1.804    0.000    5.077    0.000 trie_dict.py:29(insert)\\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</code></pre>\\n      </div>\\n<p>This startup time could be improved by implementing Node with an object with one which is faster to initialise, such as a <code>collections.namedtuple</code>.</p>\\n<p>However, this slow startup only needs to be run once, and won’t affect performance once initialised.</p>\\n<h3>Memory usage</h3>\\n<p>Tries trade off speed for memory usage. Although storing a list of words in a trie reduces the total number of characters stored4, each character stored now has overhead associated with it from the Node object which contains it, and the dict used to store its relationships.</p>\\n<p>This memory usage can be reduced by storing the words in a <a href=\\\"https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton\\\">deterministic acyclic finite state automaton</a>, which prunes some of the redundancy out of the trie.</p>\\n<h2>Extensions</h2>\\n<p>Tries can be used in similar ways to implement:</p>\\n<ul>\\n<li>An autocomplete algorithm</li>\\n<li>A sort function (insert all keys into the trie, use a depth-first-search-esque algorithm to output the keys in order)</li>\\n</ul>\\n<hr>\\n<ol>\\n<li>\\n<p>Perform binary search, but instead of searching for the string in the dictionary which == the search term, search for a string which startswith() the search term. </p>\\n</li>\\n<li>\\n<p>We are not just searching for a word in a dictionary, but also for words which could have letters added them to make them valid. We can do this by checking whether the dictionary entry starts with the letters of the search term O(m) at each step of the search O(log n) </p>\\n</li>\\n<li>\\n<p>At each step of the seach, we do a dict key lookup, which is O(1). For a word with m characters, we perform m of these lookups, giving an overall search complexity of O(m). </p>\\n</li>\\n<li>\\n<p>Storing the words ‘cat’ and ‘cab’ in a list requires storing six characters. In a trie, we only store four:</p>\\n</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>c -> a -> t\\n      `-> b</code></pre>\\n      </div>\",\n\t\t\t\t\"excerpt\": \"This article walks through writing a spell-checking algorithm, making use of a neat data structure called a  trie , which is particularly...\",\n\t\t\t\t\"fields\": {\n\t\t\t\t\t\"tagSlugs\": [\n\t\t\t\t\t\t\"/tags/data-structures/\",\n\t\t\t\t\t\t\"/tags/trie/\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Investigating tries - Writing a spell-checking algorithm\",\n\t\t\t\t\t\"tags\": [\n\t\t\t\t\t\t\"data structures\",\n\t\t\t\t\t\t\"trie\"\n\t\t\t\t\t],\n\t\t\t\t\t\"date\": \"August 24, 2017\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"slug\": \"/trie-dictionary-spellcheck/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---trie-dictionary-spellcheck-0290abea56d4521b211f.js","module.exports = {\n\t\"data\": {\n\t\t\"site\": {\n\t\t\t\"siteMetadata\": {\n\t\t\t\t\"author\": \"Naqushab Neyazee\",\n\t\t\t\t\"homeCity\": \"Noida\"\n\t\t\t}\n\t\t},\n\t\t\"markdownRemark\": {\n\t\t\t\"html\": \"<p>This article walks through writing a spell-checking algorithm, making use of a neat data structure called a <a href=\\\"https://en.wikipedia.org/wiki/Trie\\\">trie</a>, which is particularly suited to the problem.</p>\\n<p>We will look at:</p>\\n<ul>\\n<li>The spell-checking problem and naive solutions</li>\\n<li>What a trie is and how it can offer us a better solution</li>\\n<li>The trie-based solution</li>\\n<li>Analysis of our solution</li>\\n<li>How our solution can be improved</li>\\n<li>Other problems that can be solved with tries</li>\\n</ul>\\n<h2>Problem</h2>\\n<p>We wish to write a spell-checking algorithm which should return a boolean indicating whether the word might be valid or not. It should return false only if there is no possibility of the word being correct. Words which are incorrect but may be made correct with the addition of further letters should return true.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>zebr -> true\\nzebra -> true\\nzebrak -> false</code></pre>\\n      </div>\\n<p>Let’s consider some solutions using conventional data structures.</p>\\n<p><strong>List.</strong> Sort words and store them in a <code>list</code>. We can then use a modified binary search ^<em>1</em> to search for words in <code>O(m log n)</code> time ^<em>2</em>, where m is the length of the search term and n is the number of words in the dictionary. This isn’t a bad solution, but we can do better.</p>\\n<p><strong>Dict/set.</strong> Store words in a <code>dict</code> or a <code>set</code>. Dicts and sets use hashing algorithms to provide constant time (<code>O(1)</code>) lookups. This makes them seem suitable for an algorithm which is mostly about looking up whether a word is in a list. However, our spell-checker should not return false for the word the user is currently typing, even if it is not yet a valid word. In hashing the words in the list, we lose information about the word itself, and cannot map a word which can be made correct to the correct word. This makes dicts and sets unsuitable for this purpose.</p>\\n<h2>Tries</h2>\\n<p>A trie is a data structure which can store strings in a way which makes them easy to search. The following diagram shows a trie with the strings app, apple and cat stored in it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>0 -> a -> p -> p. -> l -> e.\\n `-> c -> a -> t.</code></pre>\\n      </div>\\n<p>In this diagram, <code>0</code> represents the node at the top of the trie, which has no value associated. Nodes marked are marked with a dot <code>.</code> to signify that they contain a letter which is at the end of a word.</p>\\n<p>The trie is made up of a series of interconnected nodes. Each node stores a single character, and interconnecting lines show the relationship between characters. By following the lines, we can see our three words</p>\\n<p>We can see that a trie explicitly encodes the characters of a word in its nodes, making it suitable for our spell-checking algorithm, where we need to be able to match substrings of words in the dictionary.</p>\\n<p>Our trie will need to support two operations:</p>\\n<ul>\\n<li><strong><code>insert</code></strong>, which adds a new word</li>\\n<li><strong><code>search</code></strong>, which searches for a match or potential match</li>\\n</ul>\\n<h2>Implementation</h2>\\n<p>First, let’s implement our trie. Tries consist of a series of nodes. Each node must store a value, a record of the child nodes, and whether the node points to the end of a complete word.</p>\\n<p>The child nodes can be stored in different ways, depending on the properties desired in the trie. Here, we store them in a dict, which offers fast <code>O(1)</code> lookup times, but require larger memory usage. A list could alternatively be used to reduce memory usage, at the cost of slower lookup time.</p>\\n<p>Using a <code>dict</code>, the algorithmic complexity of spell-checking a word should be <code>O(m)</code>, where <code>m</code> is the length of the string being checked ^<em>3</em>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Node(object):\\n   def __init__(self, value=None):\\n        self.value = value\\n        self.children = {}\\n        self.is_complete = False</code></pre>\\n      </div>\\n<p>The trie itself just contains a reference to the top of the string of nodes:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    def __init__(self):\\n        self.node = Node()</code></pre>\\n      </div>\\n<p>We can now implement the <code>insert</code> method:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def insert(self, key):\\n        node = self.node\\n        for letter in key:\\n            if letter in node.children:\\n                node = node.children[letter]\\n            else:\\n                new_node = Node(letter)\\n                node.children[letter] = new_node\\n                node = new_node\\n        node.is_complete = True</code></pre>\\n      </div>\\n<p>Insert takes a key to insert, iterates over it, and adds each letter to the trie, creating new nodes if necessary.</p>\\n<p><code>search</code> method:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def search(self, key):\\n        node = self.node\\n        for letter in key:\\n            if letter not in node.children:\\n                return False\\n            else:\\n                node = node.children[letter]\\n        return True</code></pre>\\n      </div>\\n<p>Search iterates over the letters in the key, checking that each node contains a child whose value matches the letter.</p>\\n<h2>Analysis</h2>\\n<h3>Comparison to binary search</h3>\\n<p>We can compare how our trie-based algorithm compares to binary search which by running a benchmark test. The test searches for 1000 randomly selected words from the dictionary 100 times each.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ python benchmark.py\\nBinary search 1000 items 100 times: 2.32307600975\\nTrie search 1000 items 100 times: 0.461572885513</code></pre>\\n      </div>\\n<h3>Complexity</h3>\\n<p>We can empirically measure the algorithm’s time complexity by measuring the time taken to search for words of variable length known to be in the trie.</p>\\n<p>\\n          <a\\n            class=\\\"gatsby-resp-image-link\\\"\\n            href=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-511e6.png\\\"\\n            style=\\\"display: block\\\"\\n            target=\\\"_blank\\\"\\n            rel=\\\"noopener\\\"\\n          >\\n            <span\\n              class=\\\"gatsby-resp-image-wrapper\\\"\\n              style=\\\"position: relative; z-index: -1; display: block; \\\"\\n            >\\n              <span\\n                class=\\\"gatsby-resp-image-background-image\\\"\\n                style=\\\"padding-bottom: 103.85674931129476%;position: relative; width: 100%; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsSAAALEgHS3X78AAABQElEQVQ4y52T2Y6DMAxF+f9/rFRUWs2UnSSQxU7mlkggllI6eYhubA6xHTsJIWitsyy73W6XywX74/FI0/R+v2fjul6vOEJYa/1yJYCVUswcz1sxaXwZ9xdiiCd4sm7FrrFURjv+D0ze/wgD9R0MhXiL3jjiEOGqqk7l7D2oUllLHC0vWAhx5ubecTuAnCv3Rdi5NHaM9jvYsa8GOzgOS2+CDjkOm32olFWWtt4EZF3XuwWDG3G2gxPaRWD1WYKma9t2t8ioDUhpXFiWfYbf5awdCUPK8m4uRwXDnU1ve8vvCjHDq4Ihz2YASQe9PcNN00w9hMare7wK+nfdYR9yxntiXAz5j1O1zhlk8SLpzEguYET5K3GlD+fmeQEr46LtYKr2cyYiTCX+IKUsyxI7dJ7nclxd1xVFEb3P5zMao/gDcjTXnEy6KcoAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n              >\\n                <img\\n                  class=\\\"gatsby-resp-image-image\\\"\\n                  style=\\\"width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n                  alt=\\\"Trie Search Complexity\\\"\\n                  title=\\\"\\\"\\n                  src=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-a408b.png\\\"\\n                  srcset=\\\"/static/763dbadfe18899d0a36eb895830c2d7d-4eabf.png 148w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-5a375.png 295w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-a408b.png 590w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-9a0cc.png 885w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-aa987.png 1180w,\\n/static/763dbadfe18899d0a36eb895830c2d7d-511e6.png 1452w\\\"\\n                  sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n                />\\n              </span>\\n            </span>\\n          </a>\\n          </p>\\n<p>Graph showing trie’s search has linear time complexity.</p>\\n<p><code>Trie.search</code> has linear time complexity, as expected.</p>\\n<h2>Improvements</h2>\\n<h3>Speed up searching successive characters in a word</h3>\\n<p>When spell-checking, a word as it is typed, we make multiple calls to the <code>search()</code> function, each time passing the previously searched value with a new character appended. For example, when typing the word ‘word’, the following searches are made:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>w\\nwo\\nwor\\nword</code></pre>\\n      </div>\\n<p>When searching for ‘wor’, you repeat the work done when searching for ‘wo’ and ‘w’. We can modify our algorithm to take this into account:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Trie(object):\\n    # ...\\n    def search(self, key, prev_node=None):\\n        node = prev_node if prev_node is not None else self.node\\n        for letter in key:\\n            if letter not in node.children:\\n                return False, node\\n            else:\\n                node = node.children[letter]\\n        return True, node</code></pre>\\n      </div>\\n<p>In this code, the last searched node is returned to the caller. The caller can then supply this node when calling search with the next character in the word to continue searching when we left off.</p>\\n<h3>Startup time</h3>\\n<p>One disadvantage of this algorithm is that initialising the trie takes some time. By profiling the insertion of the dictionary into the trie, we can see that a lot of this time is spent initialising <code>Node</code> objects:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ python profile_trie_insert.py\\n     1028667 function calls in 5.354 seconds\\n\\nOrdered by: standard name\\n\\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\\n     1    0.176    0.176    5.354    5.354 <string>:1(<module>)\\n     1    0.101    0.101    5.178    5.178 profile_trie_insert.py:6(initialise_trie)\\n792777    3.273    0.000    3.273    0.000 trie_dict.py:12(__init__)\\n     1    0.000    0.000    0.000    0.000 trie_dict.py:20(__init__)\\n235886    1.804    0.000    5.077    0.000 trie_dict.py:29(insert)\\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</code></pre>\\n      </div>\\n<p>This startup time could be improved by implementing Node with an object with one which is faster to initialise, such as a <code>collections.namedtuple</code>.</p>\\n<p>However, this slow startup only needs to be run once, and won’t affect performance once initialised.</p>\\n<h3>Memory usage</h3>\\n<p>Tries trade off speed for memory usage. Although storing a list of words in a trie reduces the total number of characters stored4, each character stored now has overhead associated with it from the Node object which contains it, and the dict used to store its relationships.</p>\\n<p>This memory usage can be reduced by storing the words in a <a href=\\\"https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton\\\">deterministic acyclic finite state automaton</a>, which prunes some of the redundancy out of the trie.</p>\\n<h2>Extensions</h2>\\n<p>Tries can be used in similar ways to implement:</p>\\n<ul>\\n<li>An autocomplete algorithm</li>\\n<li>A sort function (insert all keys into the trie, use a depth-first-search-esque algorithm to output the keys in order)</li>\\n</ul>\\n<hr>\\n<ol>\\n<li>\\n<p>Perform binary search, but instead of searching for the string in the dictionary which == the search term, search for a string which startswith() the search term. </p>\\n</li>\\n<li>\\n<p>We are not just searching for a word in a dictionary, but also for words which could have letters added them to make them valid. We can do this by checking whether the dictionary entry starts with the letters of the search term O(m) at each step of the search O(log n) </p>\\n</li>\\n<li>\\n<p>At each step of the seach, we do a dict key lookup, which is O(1). For a word with m characters, we perform m of these lookups, giving an overall search complexity of O(m). </p>\\n</li>\\n<li>\\n<p>Storing the words ‘cat’ and ‘cab’ in a list requires storing six characters. In a trie, we only store four:</p>\\n</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>c -> a -> t\\n      `-> b</code></pre>\\n      </div>\",\n\t\t\t\"excerpt\": \"This article walks through writing a spell-checking algorithm, making use of a neat data structure called a  trie , which is particularly...\",\n\t\t\t\"fields\": {\n\t\t\t\t\"tagSlugs\": [\n\t\t\t\t\t\"/tags/data-structures/\",\n\t\t\t\t\t\"/tags/trie/\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"frontmatter\": {\n\t\t\t\t\"title\": \"Investigating tries - Writing a spell-checking algorithm\",\n\t\t\t\t\"tags\": [\n\t\t\t\t\t\"data structures\",\n\t\t\t\t\t\"trie\"\n\t\t\t\t],\n\t\t\t\t\"date\": \"August 24, 2017\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"slug\": \"/trie-dictionary-spellcheck/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/trie-dictionary-spellcheck.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/trie-dictionary-spellcheck.json\n// module chunks = 6"],"sourceRoot":""}