{"version":3,"sources":["webpack:///path---hashmap-implementation-in-c-32927d171695b6fcbb4a.js","webpack:///./.cache/json/hashmap-implementation-in-c.json"],"names":["webpackJsonp","443","module","exports","data","site","siteMetadata","author","homeCity","markdownRemark","html","excerpt","fields","tagSlugs","frontmatter","title","tags","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,OAAA,mBAAAC,SAAA,UAAgDC,gBAAmBC,KAAA,m2NAAmgNC,QAAA,gJAAAC,QAAijBC,UAAA,wDAAmEC,aAAgBC,MAAA,qDAAAC,MAAA,mCAAAC,KAAA,qBAAmIC,aAAgBC,KAAA","file":"path---hashmap-implementation-in-c-32927d171695b6fcbb4a.js","sourcesContent":["webpackJsonp([231018187067477],{\n\n/***/ 443:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"author\":\"Naqushab Neyazee\",\"homeCity\":\"Noida\"}},\"markdownRemark\":{\"html\":\"<p><strong>Hash table</strong> (also <strong>hash map</strong>) is a data structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the corresponding value can be found.</p>\\n<p><img src=\\\"https://raw.githubusercontent.com/naqushab/static-assets/master/image/hashmap.png\\\" alt=\\\"Hashmap\\\"></p>\\n<p>We will go through a basic Hash Map implementation in C++ with generic type key-value pairs by using templates. It is genuinely not a production-ready implementation of HashMap class, however it simply shows how this data structure can be implemented in C++.</p>\\n<p>Below, HashNode class represents each bucket node in the table with <code>key()</code> and <code>value()</code> accessors for corresponding pair elements. It also includes a pointer to the next node with same key.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashNode.h\\n// Hash node class template\\ntemplate <typename K, typename V>\\nclass HashNode {\\npublic:\\n    HashNode(const K &key, const V &value) :\\n    key(key), value(value), next(NULL) {\\n    }\\n\\n    K getKey() const {\\n        return key;\\n    }\\n\\n    V getValue() const {\\n        return value;\\n    }\\n\\n    void setValue(V value) {\\n        HashNode::value = value;\\n    }\\n\\n    HashNode *getNext() const {\\n        return next;\\n    }\\n\\n    void setNext(HashNode *next) {\\n        HashNode::next = next;\\n    }\\n\\nprivate:\\n    // key-value pair\\n    K key;\\n    V value;\\n    // next bucket with the same key\\n    HashNode *next;\\n};</code></pre>\\n      </div>\\n<p>The hash function ideally assigns each key to a unique bucket, but most hash table designs assume that hash collisions can occur. My <a href=\\\"http://en.wikipedia.org/wiki/Hash_map#Choosing_a_good_hash_function\\\">hash function</a> just returns the remainder when the key is divided by the hash table size.\\nBy user, custom hash function class with <code>operator()</code> method implementation should be defined according to the key distribution. i.e. if the range of key values is very small, then most of the hash table is not used and chains get longer.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// KeyHash.h\\n// Default hash function class\\ntemplate <typename K>\\nstruct KeyHash {\\n    unsigned long operator()(const K& key) const\\n    {\\n        return reinterpret_cast<unsigned long>(key) % TABLE_SIZE;\\n    }\\n};</code></pre>\\n      </div>\\n<p>Below is the Hash Map implementation in C++. HashMap class contains the hash table, which is a double pointer to HashNode class and default table size in constant is used to construct this hash table.</p>\\n<p>In addition, the class contains <code>get(key)</code> function to access mapped value by key, <code>put(key,value)</code> function to put key-value pair in table and <code>remove(key)</code> function to remove hash node by key. For collision resolution, <a href=\\\"http://en.wikipedia.org/wiki/Hash_map#Separate_chaining\\\">separate chaining</a> strategy has been used.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashMap.h\\n// Hash map class template\\ntemplate <typename K, typename V, typename F = KeyHash<K>>\\nclass HashMap {\\npublic:\\n    HashMap() {\\n        // construct zero initialized hash table of size\\n        table = new HashNode<K, V> *[TABLE_SIZE]();\\n    }\\n\\n    ~HashMap() {\\n        // destroy all buckets one by one\\n        for (int i = 0; i < TABLE_SIZE; ++i) {\\n            HashNode<K, V> *entry = table[i];\\n            while (entry != NULL) {\\n                HashNode<K, V> *prev = entry;\\n                entry = entry->getNext();\\n                delete prev;\\n            }\\n            table[i] = NULL;\\n        }\\n        // destroy the hash table\\n        delete [] table;\\n    }\\n\\n    bool get(const K &key, V &value) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL) {\\n            if (entry->getKey() == key) {\\n                value = entry->getValue();\\n                return true;\\n            }\\n            entry = entry->getNext();\\n        }\\n        return false;\\n    }\\n\\n    void put(const K &key, const V &value) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *prev = NULL;\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL && entry->getKey() != key) {\\n            prev = entry;\\n            entry = entry->getNext();\\n        }\\n\\n        if (entry == NULL) {\\n            entry = new HashNode<K, V>(key, value);\\n            if (prev == NULL) {\\n                // insert as first bucket\\n                table[hashValue] = entry;\\n            } else {\\n                prev->setNext(entry);\\n            }\\n        } else {\\n            // just update the value\\n            entry->setValue(value);\\n        }\\n    }\\n\\n    void remove(const K &key) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *prev = NULL;\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL && entry->getKey() != key) {\\n            prev = entry;\\n            entry = entry->getNext();\\n        }\\n\\n        if (entry == NULL) {\\n            // key not found\\n            return;\\n        }\\n        else {\\n            if (prev == NULL) {\\n                // remove first bucket of the list\\n                table[hashValue] = entry->getNext();\\n            } else {\\n                prev->setNext(entry->getNext());\\n            }\\n            delete entry;\\n        }\\n    }\\n\\nprivate:\\n    // hash table\\n    HashNode<K, V> **table;\\n    F hashFunc;\\n};</code></pre>\\n      </div>\\n<p>As an example usage, you first create a container by template initialising and put key-value pairs in it. Then, you can get or remove elements from the map. If the key searched does not exist, false is returned and value is not updated.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashMapTest.cpp\\n\\nstruct MyKeyHash {\\n    unsigned long operator()(const int& k) const\\n    {\\n        return k % 10;\\n    }\\n};\\n\\nHashMap<int, string, MyKeyHash> hmap;\\nhmap.put(1, \\\"val1\\\");\\nhmap.put(2, \\\"val2\\\");\\nhmap.put(3, \\\"val3\\\");\\n\\nstring value;\\nhmap.get(2, value);\\ncout << value << endl;\\nbool res = hmap.get(3, value);\\nif (res)\\n    cout << value << endl;\\nhmap.remove(3);\\nres = hmap.get(3, value);\\nif (res)\\n    cout << value << endl;</code></pre>\\n      </div>\\n<p>This is basic and complete hash map, but some of the expected functionality is missing. I can call some of them:</p>\\n<ul>\\n<li>Iterators for traversal,</li>\\n<li>comparator for key comparisons,</li>\\n<li>capacity and size functions,</li>\\n<li>load factor and rehashing,</li>\\n<li>allocator for dynamic memory allocations, and</li>\\n<li>thread safety.</li>\\n</ul>\",\"excerpt\":\"Hash table  (also  hash map ) is a data structure that can map keys to values. A hash table uses a hash function to compute an index into anâ€¦\",\"fields\":{\"tagSlugs\":[\"/tags/c/\",\"/tags/hash-map/\",\"/tags/data-structures/\"]},\"frontmatter\":{\"title\":\"Simple Hash Map (Hash Table) Implementation in C++\",\"tags\":[\"C++\",\"HashMap\",\"Data Structures\"],\"date\":\"August 25, 2017\"}}},\"pathContext\":{\"slug\":\"/hashmap-implementation-in-c/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---hashmap-implementation-in-c-32927d171695b6fcbb4a.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"author\":\"Naqushab Neyazee\",\"homeCity\":\"Noida\"}},\"markdownRemark\":{\"html\":\"<p><strong>Hash table</strong> (also <strong>hash map</strong>) is a data structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the corresponding value can be found.</p>\\n<p><img src=\\\"https://raw.githubusercontent.com/naqushab/static-assets/master/image/hashmap.png\\\" alt=\\\"Hashmap\\\"></p>\\n<p>We will go through a basic Hash Map implementation in C++ with generic type key-value pairs by using templates. It is genuinely not a production-ready implementation of HashMap class, however it simply shows how this data structure can be implemented in C++.</p>\\n<p>Below, HashNode class represents each bucket node in the table with <code>key()</code> and <code>value()</code> accessors for corresponding pair elements. It also includes a pointer to the next node with same key.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashNode.h\\n// Hash node class template\\ntemplate <typename K, typename V>\\nclass HashNode {\\npublic:\\n    HashNode(const K &key, const V &value) :\\n    key(key), value(value), next(NULL) {\\n    }\\n\\n    K getKey() const {\\n        return key;\\n    }\\n\\n    V getValue() const {\\n        return value;\\n    }\\n\\n    void setValue(V value) {\\n        HashNode::value = value;\\n    }\\n\\n    HashNode *getNext() const {\\n        return next;\\n    }\\n\\n    void setNext(HashNode *next) {\\n        HashNode::next = next;\\n    }\\n\\nprivate:\\n    // key-value pair\\n    K key;\\n    V value;\\n    // next bucket with the same key\\n    HashNode *next;\\n};</code></pre>\\n      </div>\\n<p>The hash function ideally assigns each key to a unique bucket, but most hash table designs assume that hash collisions can occur. My <a href=\\\"http://en.wikipedia.org/wiki/Hash_map#Choosing_a_good_hash_function\\\">hash function</a> just returns the remainder when the key is divided by the hash table size.\\nBy user, custom hash function class with <code>operator()</code> method implementation should be defined according to the key distribution. i.e. if the range of key values is very small, then most of the hash table is not used and chains get longer.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// KeyHash.h\\n// Default hash function class\\ntemplate <typename K>\\nstruct KeyHash {\\n    unsigned long operator()(const K& key) const\\n    {\\n        return reinterpret_cast<unsigned long>(key) % TABLE_SIZE;\\n    }\\n};</code></pre>\\n      </div>\\n<p>Below is the Hash Map implementation in C++. HashMap class contains the hash table, which is a double pointer to HashNode class and default table size in constant is used to construct this hash table.</p>\\n<p>In addition, the class contains <code>get(key)</code> function to access mapped value by key, <code>put(key,value)</code> function to put key-value pair in table and <code>remove(key)</code> function to remove hash node by key. For collision resolution, <a href=\\\"http://en.wikipedia.org/wiki/Hash_map#Separate_chaining\\\">separate chaining</a> strategy has been used.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashMap.h\\n// Hash map class template\\ntemplate <typename K, typename V, typename F = KeyHash<K>>\\nclass HashMap {\\npublic:\\n    HashMap() {\\n        // construct zero initialized hash table of size\\n        table = new HashNode<K, V> *[TABLE_SIZE]();\\n    }\\n\\n    ~HashMap() {\\n        // destroy all buckets one by one\\n        for (int i = 0; i < TABLE_SIZE; ++i) {\\n            HashNode<K, V> *entry = table[i];\\n            while (entry != NULL) {\\n                HashNode<K, V> *prev = entry;\\n                entry = entry->getNext();\\n                delete prev;\\n            }\\n            table[i] = NULL;\\n        }\\n        // destroy the hash table\\n        delete [] table;\\n    }\\n\\n    bool get(const K &key, V &value) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL) {\\n            if (entry->getKey() == key) {\\n                value = entry->getValue();\\n                return true;\\n            }\\n            entry = entry->getNext();\\n        }\\n        return false;\\n    }\\n\\n    void put(const K &key, const V &value) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *prev = NULL;\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL && entry->getKey() != key) {\\n            prev = entry;\\n            entry = entry->getNext();\\n        }\\n\\n        if (entry == NULL) {\\n            entry = new HashNode<K, V>(key, value);\\n            if (prev == NULL) {\\n                // insert as first bucket\\n                table[hashValue] = entry;\\n            } else {\\n                prev->setNext(entry);\\n            }\\n        } else {\\n            // just update the value\\n            entry->setValue(value);\\n        }\\n    }\\n\\n    void remove(const K &key) {\\n        unsigned long hashValue = hashFunc(key);\\n        HashNode<K, V> *prev = NULL;\\n        HashNode<K, V> *entry = table[hashValue];\\n\\n        while (entry != NULL && entry->getKey() != key) {\\n            prev = entry;\\n            entry = entry->getNext();\\n        }\\n\\n        if (entry == NULL) {\\n            // key not found\\n            return;\\n        }\\n        else {\\n            if (prev == NULL) {\\n                // remove first bucket of the list\\n                table[hashValue] = entry->getNext();\\n            } else {\\n                prev->setNext(entry->getNext());\\n            }\\n            delete entry;\\n        }\\n    }\\n\\nprivate:\\n    // hash table\\n    HashNode<K, V> **table;\\n    F hashFunc;\\n};</code></pre>\\n      </div>\\n<p>As an example usage, you first create a container by template initialising and put key-value pairs in it. Then, you can get or remove elements from the map. If the key searched does not exist, false is returned and value is not updated.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">// HashMapTest.cpp\\n\\nstruct MyKeyHash {\\n    unsigned long operator()(const int& k) const\\n    {\\n        return k % 10;\\n    }\\n};\\n\\nHashMap<int, string, MyKeyHash> hmap;\\nhmap.put(1, \\\"val1\\\");\\nhmap.put(2, \\\"val2\\\");\\nhmap.put(3, \\\"val3\\\");\\n\\nstring value;\\nhmap.get(2, value);\\ncout << value << endl;\\nbool res = hmap.get(3, value);\\nif (res)\\n    cout << value << endl;\\nhmap.remove(3);\\nres = hmap.get(3, value);\\nif (res)\\n    cout << value << endl;</code></pre>\\n      </div>\\n<p>This is basic and complete hash map, but some of the expected functionality is missing. I can call some of them:</p>\\n<ul>\\n<li>Iterators for traversal,</li>\\n<li>comparator for key comparisons,</li>\\n<li>capacity and size functions,</li>\\n<li>load factor and rehashing,</li>\\n<li>allocator for dynamic memory allocations, and</li>\\n<li>thread safety.</li>\\n</ul>\",\"excerpt\":\"Hash table  (also  hash map ) is a data structure that can map keys to values. A hash table uses a hash function to compute an index into anâ€¦\",\"fields\":{\"tagSlugs\":[\"/tags/c/\",\"/tags/hash-map/\",\"/tags/data-structures/\"]},\"frontmatter\":{\"title\":\"Simple Hash Map (Hash Table) Implementation in C++\",\"tags\":[\"C++\",\"HashMap\",\"Data Structures\"],\"date\":\"August 25, 2017\"}}},\"pathContext\":{\"slug\":\"/hashmap-implementation-in-c/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/hashmap-implementation-in-c.json\n// module id = 443\n// module chunks = 231018187067477"],"sourceRoot":""}