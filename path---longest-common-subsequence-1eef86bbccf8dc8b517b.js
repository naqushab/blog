webpackJsonp([0xd9249c5daa02],{448:function(n,e){n.exports={data:{site:{siteMetadata:{author:"Naqushab Neyazee",homeCity:"Noida"}},markdownRemark:{html:'<p>The longest common subsequence (LCS) problem is the problem of finding the longest subsequence that is present in given two sequences in the same order. i.e. find a longest sequence which can be obtained from the first original sequence by deleting some items, and from the second original sequence by deleting other items.</p>\n<p>The problem differs from problem of finding common substrings. Unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.\nFor example, consider the two following sequences X and Y</p>\n<p>X: ABCBDAB\nY: BDCABA</p>\n<p>The length of LCS is 4\nLCS are BDAB, BCAB and BCBA</p>\n<p>The LCS problem has an optimal substructure. That means the problem can be broken down into smaller, simple “subproblems”, which can be broken down into yet simpler subproblems, and so on, until, finally, the solution becomes trivial.</p>\n<ol>\n<li>Let us consider two sequences X and Y of length m and n that both end in the same element.\nTo find their LCS, shorten each sequence by removing the last element, find the LCS of the shortened sequences, and to that LCS append the removed element. So we can say that</li>\n</ol>\n<p><code>LCS(X[1..m], Y[1..n]) = LCS(X[1..m-1], Y[1..n-1]) + X[m] if X[m] = Y[n]</code></p>\n<ol start="2">\n<li>Now suppose that the two sequences do not end in the same symbol.\nThen the LCS of X and Y is the longer of the two sequences LCS(X[1..m-1], Y[1..n]) and LCS(X[1..m], Y[1..n-1]). To understand this property, let’s consider the two following sequences\nX: ABCBDAB (n elements)\nY: BDCABA  (m elements)</li>\n</ol>\n<p>The LCS of these two sequences either ends with a B (the last element of sequence X) or does not.</p>\n<p>Case 1: If LCS ends with a B, then it cannot end with a A and we can remove the A from sequence Y and the problem reduces to <code>LCS(X[1..m], Y[1..n-1])</code>.</p>\n<p>Case 2: If LCS does not end with a B, then we can remove B from the sequence X and the problem reduces to <code>LCS(X[1..m-1], Y[1..n])</code>. For example,</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code class="language-none">LCS(‘ABCBDAB’, ‘BDCABA’) = maximum (LCS(‘ABCBDA’, ‘BDCABA’),\n                                    LCS(‘ABCBDAB’, ‘BDCAB’))\nLCS(‘ABCBDA’, ‘BDCABA’) = LCS(‘ABCBD’, ‘BDCAB’) + ‘A’\nLCS(‘ABCBDAB’, ‘BDCAB’) = LCS(‘ABCBDA’, ‘BDCA’) + ‘B’\n\nLCS(‘ABCBD’, ‘BDCAB’) = maximum (LCS(‘ABCB’, ‘BDCAB’), LCS(‘ABCBD’, ‘BDCA’))\nLCS(‘ABCBDA’, ‘BDCA’) = LCS(‘ABCBD’, ‘BDC’) + ‘A’</code></pre>\n      </div>\n<p>and so on..</p>\n<h2>Implementation</h2>\n<h3>Top Down</h3>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code class="language-none">#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\n// Function to find length of Longest Common Subsequence of substring\n// X[0..m-1] and Y[0..n-1]\nint LCSLength(string X, string Y, int m, int n, auto &lookup)\n{\n    // return if we have reached the end of either string\n    if (m == 0 || n == 0)\n        return 0;\n\n    // construct a unique map key from dynamic elements of the input\n    string key = to_string(m) + "|" + to_string(n);\n\n    // if sub-problem is seen for the first time, solve it and\n    // store its result in a map\n    if (lookup.find(key) == lookup.end())\n    {\n        // if last character of X and Y matches\n        if (X[m - 1] == Y[n - 1])\n            lookup[key] = LCSLength(X, Y, m - 1, n - 1, lookup) + 1;\n\n        else\n        // else if last character of X and Y don\'t match\n        lookup[key] = max(LCSLength(X, Y, m, n - 1, lookup),\n                          LCSLength(X, Y, m - 1, n, lookup));\n    }\n\n    // return the subproblem solution from the map\n    return lookup[key];\n}\n\n// Longest Common Subsequence\nint main()\n{\n    string X = "ABCBDAB", Y = "BDCABA";\n\n    // create a map to store solutions of subproblems\n    unordered_map<string, int> lookup;\n\n    cout << "The length of LCS is "\n        << LCSLength(X, Y, X.length(), Y.length(), lookup);\n\n    return 0;\n}</code></pre>\n      </div>\n<p>The time complexity of above solution is O(mn) and auxiliary space used by the program is O(mn). </p>\n<h3>Bottom Up</h3>\n<p>In the bottom-up approach, we calculate the smaller values of LCS(i, j) first, then build larger values from them.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code class="language-none">            | 0                                          if i == 0 or j == 0\nLCS[i][j] = | LCS[i – 1][j – 1] + 1                      if X[i-1] == Y[j-1]\n            | longest(LCS[i – 1][j], LCS[i][j – 1])      if X[i-1] != Y[j-1]</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code class="language-none">#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to find length of Longest Common Subsequence of substring\n// X[0..m-1] and Y[0..n-1]\nint LCSLength(string X, string Y)\n{\n    int m = X.length(), n = Y.length();\n\n    // lookup table stores solution to already computed sub-problems\n    // i.e. lookup[i][j] stores the length of LCS of substring\n    // X[0..i-1] and Y[0..j-1]\n    int lookup[m + 1][n + 1];\n\n    // first column of the lookup table will be all 0\n    for (int i = 0; i <= m; i++)\n        lookup[i][0] = 0;\n\n    // first row of the lookup table will be all 0\n    for (int j = 0; j <= n; j++)\n        lookup[0][j] = 0;\n\n    // fill the lookup table in bottom-up manner\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            // if current character of X and Y matches\n            if (X[i - 1] == Y[j - 1])\n                lookup[i][j] = lookup[i - 1][j - 1] + 1;\n\n            // else if current character of X and Y don\'t match\n            else\n                lookup[i][j] = max(lookup[i - 1][j], lookup[i][j - 1]);\n        }\n    }\n\n    // LCS will be last entry in the lookup table\n    return lookup[m][n];\n}\n\n// Longest Common Subsequence\nint main()\n{\n    string X = "XMJYAUZ", Y = "MZJAWXU";\n\n    cout << "The length of LCS is " << LCSLength(X, Y);\n\n    return 0;\n}</code></pre>\n      </div>\n<p>The time complexity of above solution is O(mn) and auxiliary space used by the program is O(mn). The space compexity of above solution can be improved to O(n) as calculating LCS of a row of the LCS table requires only the solutions to the current row and the previous row.</p>',excerpt:"The longest common subsequence (LCS) problem is the problem of finding the longest subsequence that is present in given two sequences in the…",fields:{tagSlugs:["/tags/dynamic-programming/","/tags/algorithms/"]},frontmatter:{title:"Longest Common Subsequence",tags:["Dynamic-Programming","Algorithms"],date:"March 27, 2018"}}},pathContext:{slug:"/longest-common-subsequence/"}}}});
//# sourceMappingURL=path---longest-common-subsequence-1eef86bbccf8dc8b517b.js.map